#ifndef RW_CORE_BASEOBJECT_HPP
#define RW_CORE_BASEOBJECT_HPP

#include "RedWolf/RedWolfManager.hpp"
#include "RedWolf/common.hpp"
#include "RedWolf/events/BaseEvent.hpp"
#include "RedWolf/events/concepts.hpp"
#include "RedWolf/thread/ThreadPool.hpp"

#include <iostream>
#include <map>
#include <set>
#include <shared_mutex>
#include <string_view>
#include <thread>
#include <utility>

namespace rw::core
{
   /**
    * @brief Base class for all objects that need to be hooked up with the event system of RedWolf.
    */
   class RW_API BaseObject
   {
   public:
      /**
       * @brief Constructor.
       * @param manager RedWolf library manager.
       * @param parent Logical parent of the object. Not related to memory management like in other libraries (eg. QT).
       */
      explicit BaseObject(RedWolfManager& manager, BaseObject* parent = nullptr);

      /**
       * @brief Generate an event and propagate it to all subscribers using a dedicated thread.
       * @tparam Event Event type to generate.
       * @param evnt Event data to send.
       */
      template<rw::events::HasEventID Event>
      void generateEvent(const Event& evnt)
      {
         threadPool_->addTask(
            [this, evnt]()
            {
               std::shared_lock lck_{ subscriberMutex_ };

               for (auto& subscriber : subscribers_[evnt.id])
               {
                  subscriber->handle(evnt, this);
               }
            });
      }

      /**
       * @brief Handle an incoming event.
       * @param evnt Event data.
       * @param sender Sender of the event.
       */
      virtual void handle(const rw::events::BaseEvent& evnt, const BaseObject* sender);

      /**
       * @brief Set a new parent for the object.
       * @detail This function does not change the parent subscriptions from this object. For this, each derived class must override this
       * method and add specific functionality.
       * @param parent New parent.
       */
      virtual void setParent(BaseObject* parent);

      /**
       * @brief Subscribe an object to an event generated by this object.
       * @tparam Event Event type that the object wants to receive.
       * @param object Object that wants to subscribe to the event.
       */
      template<rw::events::HasEventID Event>
      void subscribe(BaseObject* object)
      {
         std::scoped_lock lck_{ subscriberMutex_ };
         if (!subscribers_[Event::event_id].contains(object))
         {
            subscribers_[Event::event_id].insert(object);
         }
      }

      /**
       * @brief Unsubscribe a previously subscribed object from a specific event.
       * @tparam Event Event type that the object wants to unsubscribe from.
       * @param object Object that wants to unsubscribe from the event.
       */
      template<rw::events::HasEventID Event>
      void unsubscribe(BaseObject* object)
      {
         std::scoped_lock lck_{ subscriberMutex_ };
         auto             subscriber = subscribers_[Event::event_id].find(object);
         if (subscriber != subscribers_[Event::event_id].end())
         {
            subscribers_[Event::event_id].erase(subscriber);
         }
      }

   protected:
      /**
       * @brief User handle function for incoming events. To be implemented in derived classes.
       * @details The operations performed in this function must be protected by some kind of thread synchronisation mechanism, because
       * events could be generated from different threads (eg. rw::time::Timer).
       * @param evnt Event data.
       * @param sender Sender of the event.
       */
      virtual void userHandle_(const rw::events::BaseEvent& evnt, const BaseObject* sender) = 0;

   private:
      BaseObject* parent_{ nullptr }; /**< Logical parent of the object. */

      /**
       * @brief List of objects subscribed to the event handling system.
       */
      std::map<unsigned int, std::set<BaseObject*>> subscribers_;
      std::shared_mutex                             subscriberMutex_;       /**< Mutex for protecting subscribe/unsubscribe operations. */
      rw::thread::ThreadPool*                       threadPool_{ nullptr }; /**< Thread pool used for event propagation. */
   };
} // namespace rw::core

#endif