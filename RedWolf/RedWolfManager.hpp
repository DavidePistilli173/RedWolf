#ifndef RW_REDWOLFMANAGER_HPP
#define RW_REDWOLFMANAGER_HPP

#include "RedWolf/common.hpp"
#include "RedWolf/core/Object.hpp"
#include "RedWolf/core/concepts.hpp"
#include "RedWolf/dat/VersionInfo.hpp"
#include "RedWolf/evt/EventHandler.hpp"
#include "RedWolf/lif/glfw/Manager.hpp"
#include "RedWolf/util/Logger.hpp"

#include <memory>
#include <mutex>
#include <unordered_map>

namespace rw
{
   /**
    * @brief RedWolf library manager.
    */
   class RW_API RedWolfManager
   {
   public:
      /**
       * @brief Options to be passed to the manager.
       */
      struct Options
      {
         std::string          appName;               /**< Name of the user application. */
         rw::dat::VersionInfo appVersion{ 0, 0, 0 }; /**< Version of the user application. */
      };

      /**
       * @brief Constructor.
       */
      explicit RedWolfManager(const Options& options);

      /**
       * @brief Destructor.
       */
      ~RedWolfManager() = default;

      /**
       * @brief Copy constructor.
       */
      RedWolfManager(const RedWolfManager&) = delete;

      /**
       * @brief Move constructor.
       */
      RedWolfManager(RedWolfManager&&) = default;

      /**
       * @brief Copy-assignment operator.
       */
      RedWolfManager& operator=(const RedWolfManager&) = delete;

      /**
       * @brief Move-assignment operator.
       */
      RedWolfManager& operator=(RedWolfManager&&) = delete;

      /**
       * @brief Create a new RedWolf object.
       * @tparam ...Args Types of arguments that will be passed to the object's constructor.
       * @tparam T Type of object to create.
       * @param ...args Arguments passed to the object's constructor.
       * @return Non-owning pointer to the object.
       */
      template<rw::core::IsDerivedFrom<rw::core::Object> T, typename... Args>
      [[nodiscard]] T* createObject(Args&&... args);

      /**
       * @brief Destroy a RedWolf object.
       * @param obj Pointer to the object to destroy.
       */
      void destroyObject(rw::core::Object* obj);

      /**
       * @brief Subscribe an object to an event generated by another object.
       * @param generator Object that will generate the event.
       * @param suscriber Object that wants to subscribe to the event.
       * @param eventId ID of the event to subscribe to.
       */
      void subscribe(const rw::core::BaseObject* generator, rw::core::BaseObject* subscriber, rw::evt::EventID eventId);

      /**
       * @brief Unsubscribe a previously subscribed object from a specific event.
       * @param generator Object that will generate the events.
       * @param suscriber Object that wants to unsubscribe from the event.
       * @param eventId ID of the event to unsubscribe from.
       */
      void unsubscribe(const rw::core::BaseObject* generator, rw::core::BaseObject* subscriber, rw::evt::EventID eventId);

   private:
      std::mutex mtx_; /**< Mutex for protecting private variables. */

      const Options options_; /**< Library options. */

      rw::util::Logger logger_; /**< Library logger. */

      std::unordered_map<rw::core::Object*, std::unique_ptr<rw::core::Object>> objects_;      /**< All library-managed objects. */
      rw::evt::EventHandler                                                    eventHandler_; /**< Library event handler. */

      rw::lif::glfw::Manager glfwManager_; /**< GLFW library manager. */
   };
} // namespace rw

// IMPLEMENTATION
using namespace rw;

template<rw::core::IsDerivedFrom<rw::core::Object> T, typename... Args>
[[nodiscard]] T* RedWolfManager::createObject(Args&&... args)
{
   std::scoped_lock lck{ mtx_ };

   auto obj = std::make_unique<T>(std::forward<Args>(args)...);
   auto result = obj.get();
   objects_.emplace(result, std::move(obj));
   eventHandler_.addObject(result);
   result->setEventHandler(&eventHandler_);
   return result;
}

#endif