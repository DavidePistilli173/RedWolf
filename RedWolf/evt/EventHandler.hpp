#ifndef RW_EVT_EVENTHANDLER_HPP
#define RW_EVT_EVENTHANDLER_HPP

#include "RedWolf/common.hpp"
#include "RedWolf/core/BaseObject.hpp"
#include "RedWolf/core/concepts.hpp"
#include "RedWolf/evt/aliases.hpp"
#include "RedWolf/thread/ThreadPool.hpp"
#include "RedWolf/util/Logger.hpp"

#include <map>
#include <shared_mutex>
#include <vector>

namespace rw::evt
{
   /**
    * @brief Class for handling event subscribing, unsubscribing and dispatching.
    */
   class RW_API EventHandler
   {
   public:
      /**
       * @brief All supported policies for generating events.
       */
      enum class GenerationPolicy
      {
         asynchronous, /**< Event generation is performed asynchronously on another thread. */
         synchronous   /**< Event generation is performed synchronously on the calling thread. */
      };

      /**
       * @brief Default constructor.
       * @param logger Logger to use.
       */
      explicit EventHandler(rw::util::Logger& logger);

      /**
       * @brief Add a new object to the event system.
       * @param object Object to add to the event system.
       */
      void addObject(rw::core::BaseObject* object);

      // TODO: Move method definition outside of class. Defined here because of a bug in MSVC.
      /**
       * @brief Generate an event and propagate it to all subscribers using a dedicated thread.
       * @tparam T Event type to generate.
       * @param generator Object that generated the event.
       * @param evnt Event data to send.
       * @param policy Policy for the event generation.
       */
      template<rw::core::IsDerivedFrom<Event> T>
      void generateEvent(const rw::core::BaseObject* generator, const T& evt, GenerationPolicy policy = GenerationPolicy::asynchronous)
      {
         auto propagateEvent = [this, generator, evt]()
         {
            std::shared_lock lck_{ mtx_ };

            if (!objects_.contains(generator))
            {
               logger_.warn("Event generator {} already destroyed.", generator);
               return;
            }

            for (auto& subscriber : objects_[generator][evt.id])
            {
               subscriber->handle(generator, evt);
            }
         };

         switch (policy)
         {
         case GenerationPolicy::asynchronous:
            threadPool_.addTask(propagateEvent);
            break;
         case GenerationPolicy::synchronous:
            propagateEvent();
            break;
         }
      }

      /**
       * @brief Remove an object from the event system.
       * @param object Object to remove from the event system.
       */
      void removeObject(rw::core::BaseObject* object);

      /**
       * @brief Subscribe an object to an event generated by another object.
       * @param generator Object that will generate the event.
       * @param suscriber Object that wants to subscribe to the event.
       * @param eventId ID of the event to subscribe to.
       */
      void subscribe(const rw::core::BaseObject* generator, rw::core::BaseObject* subscriber, EventID eventId);

      /**
       * @brief Unsubscribe a previously subscribed object from a specific event.
       * @param generator Object that will generate the events.
       * @param suscriber Object that wants to unsubscribe from the event.
       * @param eventId ID of the event to unsubscribe from.
       */
      void unsubscribe(const rw::core::BaseObject* generator, rw::core::BaseObject* subscriber, EventID eventId);

   private:
      rw::util::Logger&      logger_;     /**< RedWolf library logger. */
      rw::thread::ThreadPool threadPool_; /**< RedWolf library thread pool. */

      std::shared_mutex mtx_; /**< Mutex for protecting write access to the subscribers map. */

      /**
       * @brief Map of all RedWolf objects with all their subscribers for each event ID.
       * @details This is a map containing all RedWolf objects.
       *          For each object, there is a map of all subscribers, divided by event ID.
       *          For each event ID, there is a vector of all objects subscribed to that event.
       */
      std::unordered_map<const rw::core::BaseObject*, std::unordered_map<EventID, std::vector<rw::core::BaseObject*>>> objects_;
   };
} // namespace rw::evt

#endif